################################################################################
#                                                                              #
#                        _____ _   _  _____ _______ _                          #
#                       |_   _| \ | |/ ____|__   __| |                         #
#                         | | |  \| | (___    | |  | |                         #
#                         | | | . ` |\___ \   | |  | |                         #
#                        _| |_| |\  |____) |  | |  | |____                     #
#                       |_____|_| \_|_____/   |_|  |______|                    #
#                                                                              #
#                                                                              #
#             Instl is an automated installer for GitHub Projects.             #
#          This script is automatically generated by https://instl.sh.         #
#                                                                              #
#    Running this script will install the specified GitHub project on your     #
#                                   system.                                    #
#                                                                              #
#  For full transperancy this script is a single file, combined from multiple  #
#                                   files.                                     #
#                                                                              #
#            You can see the source code of this server on GitHub:             #
#                  https://github.com/installer/instl                          #
#                                                                              #
#             Instl and its members are not associated with the                #
#                       project that will be installed!                        #
#                                                                              #
#                                                                              #
#              This script will perform the following actions:                 #
#          - Fetch the project metadata from the public GitHub API             #
#                  - Find the right asset for your system                      #
#                     - Download the asset from GitHub                         #
#                - Extract the asset to the correct location                   #
#            - Add the installation directory to your system PATH              #
################################################################################

# Install script for: https://github.com/yisuschrist/urls_organizer
#
# To use this installer script, run the following command:
#
# Linux:
# curl -sSL instl.sh/yisuschrist/urls_organizer/linux | bash
#
# macOS:
# curl -sSL instl.sh/yisuschrist/urls_organizer/macos | bash
#
# Windows:
# iwr instl.sh/yisuschrist/urls_organizer/windows | iex



# Import libraries
# --- Sourced from file: ./lib/colors.sh ---

# Foreground Colors

fRed() {
  printf "\e[31m%s\e[0m" "$1"
}

fRedLight() {
  printf "\e[91m%s\e[0m" "$1"
}

fYellow() {
  printf "\e[33m%s\e[0m" "$1"
}

fYellowLight() {
  printf "\e[93m%s\e[0m" "$1"
}

fGreen() {
  printf "\e[32m%s\e[0m" "$1"
}

fGreenLight() {
  printf "\e[92m%s\e[0m" "$1"
}

fBlue() {
  printf "\e[34m%s\e[0m" "$1"
}

fBlueLight() {
  printf "\e[94m%s\e[0m" "$1"
}

fMagenta() {
  printf "\e[35m%s\e[0m" "$1"
}

fMagentaLight() {
  printf "\e[95m%s\e[0m" "$1"
}

fCyan() {
  printf "\e[36m%s\e[0m" "$1"
}

fCyanLight() {
  printf "\e[96m%s\e[0m" "$1"
}

fWhite() {
  printf "\e[37m%s\e[0m" "$1"
}

fBlack() {
  printf "\e[30m%s\e[0m" "$1"
}

fGray() {
  printf "\e[90m%s\e[0m" "$1"
}

fGrayLight() {
  printf "\e[37m%s\e[0m" "$1"
}

## Background Colors
bRed() {
  printf "\e[41m%s\e[0m" "$1"
}

bRedLight() {
  printf "\e[101m%s\e[0m" "$1"
}

bYellow() {
  printf "\e[43m%s\e[0m" "$1"
}

bYellowLight() {
  printf "\e[103m%s\e[0m" "$1"
}

bGreen() {
  printf "\e[42m%s\e[0m" "$1"
}

bGreenLight() {
  printf "\e[102m%s\e[0m" "$1"
}

bBlue() {
  printf "\e[44m%s\e[0m" "$1"
}

bBlueLight() {
  printf "\e[104m%s\e[0m" "$1"
}

bMagenta() {
  printf "\e[45m%s\e[0m" "$1"
}

bMagentaLight() {
  printf "\e[105m%s\e[0m" "$1"
}

bCyan() {
  printf "\e[46m%s\e[0m" "$1"
}

bCyanLight() {
  printf "\e[106m%s\e[0m" "$1"
}

bWhite() {
  printf "\e[47m%s\e[0m" "$1"
}

bBlack() {
  printf "\e[40m%s\e[0m" "$1"
}

bGray() {
  printf "\e[100m%s\e[0m" "$1"
}

bGrayLight() {
  printf "\e[37m%s\e[0m" "$1"
}


# Special Colors

resetColor() {
  printf "\e[0m"
}

# Theme

primaryColor() {
  fCyan "$1"
}

secondaryColor() {
  fMagentaLight "$1"
}

info() {
  fBlueLight " i " && resetColor && fBlue "$1" && echo
}

warning() {
  fYellowLight " ! " && resetColor && fYellow "$1" && echo
}

error() {
  fRedLight " X " && resetColor && fRed "$1" && echo
}

success() {
  fGreenLight " + " && resetColor && fGreen "$1" && echo
}

verbose() {
  if [ $verbose == true ]; then
    fGrayLight " > " && resetColor && fGray "$1" && echo
  fi
}

# --- End of ./lib/colors.sh ---


# --- Sourced from file: ./lib/map.sh ---

# map_put map_name key value
function map_put {
  alias "${1}$2"="$3"
}

# map_get map_name key
# @return value
function map_get {
  alias "${1}$2" | awk -F"'" '{ print $2; }'
}

# map_keys map_name
# @return map keys
function map_keys {
  alias -p | grep $1 | cut -d'=' -f1 | awk -F"$1" '{print $2; }'
}

# --- End of ./lib/map.sh ---



# Setup variables
verbose="true"
if [ "$verbose" = "true" ]; then
  verbose=true
else
  verbose=false
fi

verbose "Setting up variables"
owner="yisuschrist"
repo="urls_organizer"
verbose "Creating temporary directory"
tmpDir="$(mktemp -d)"

binaryLocation="$HOME/.local/bin/scripts"
verbose "Binary location: $binaryLocation"
mkdir -p $binaryLocation

installLocation="$HOME/.local/bin/.instl/$repo"
verbose "Install location: $installLocation"
# Remove installLocation directory if it exists
if [ -d "$installLocation" ]; then
  verbose "Removing existing install location"
  rm -rf "$installLocation"
fi
mkdir -p $installLocation

# Print "INSTL" header
# --- Sourced from file: ../shared/intro.ps1 ---

secondaryColor '
                           _____ _   _  _____ _______ _
                          |_   _| \ | |/ ____|__   __| |
                            | | |  \| | (___    | |  | |
                            | | | . ` |\___ \   | |  | |
                           _| |_| |\  |____) |  | |  | |____
                          |_____|_| \_|_____/   |_|  |______|'
echo ""
echo ""
fBlueLight '                       Instl is an installer for GitHub Projects'
echo ""
fBlue '                                > https://instl.sh'
echo ""
echo ""

# --- End of ../shared/intro.ps1 ---



# Check if repository exists
info "Ensuring repository exists"
repoURL="https://api.github.com/repos/$owner/$repo"
cmd="curl --silent --head --write-out '%{http_code}' \"$repoURL\" -o /dev/null"
verbose "$cmd"
httpStatusCode="$(eval "$cmd")"
if [[ "$httpStatusCode" -eq 403 ]]; then
  error "API rate limit exceeded. Try again in a few minutes."
  exit 1
elif [[ "$httpStatusCode" -ne 200 ]]; then
  error "Repository $owner/$repo does not exist."
  exit 1
fi

# Installation
curlOpts=("-sS --retry 10 --retry-all-errors --retry-delay 1")
if [ -n "$GH_TOKEN" ]; then
  verbose "Using authentication with GH_TOKEN"
  curlOpts+=("--header \"Authorization: Bearer $GH_TOKEN\"")
elif [ -n "$GITHUB_TOKEN" ]; then
  verbose "Using authentication with GITHUB_TOKEN"
  curlOpts+=("--header \"Authorization: Bearer $GITHUB_TOKEN\"")
else
  verbose "No authentication"
fi

# GitHub public API
latestReleaseURL="https://api.github.com/repos/$owner/$repo/releases/latest"
verbose "Getting latest release from GitHub"
getReleaseArgs=$curlOpts
getReleaseArgs+=("$latestReleaseURL")
cmd="curl ${getReleaseArgs[@]}"
verbose "$cmd"
releaseJSON="$(eval "$cmd")"
if [ $? -ne 0 ]; then
  error "Error while running the curl command."
  exit 1
fi
tagName="$(echo "$releaseJSON" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')"
info "Found latest release of $repo (version: $tagName)"

# Get list of assets
verbose "Parsing release json"
assets=$(echo "$releaseJSON" | grep "browser_download_url" | sed -E 's/.*"([^"]+)".*/\1/')
if [ $? -ne 0 ]; then
  error "Error while parsing the release json."
  exit 1
fi
if [ -z "$assets" ]; then
  info "No assets found in release '$tagName'"
  info "Searching for source code archive..." 

  assetName="$tagName.tar.gz"
  # Get asset URL from release assets
  assetURL="https://github.com/$owner/$repo/archive/refs/tags/$assetName"
else
  verbose "Found assets:"$'\n'"$assets"

  assetCount="$(echo "$assets" | wc -l | sed -E 's/^[[:space:]]*//')"
  info "Found $assetCount assets in '$tagName' release"
  info "Searching for one that fits your system..."
  # Get architecture of host
  arch="$(uname -m)"
  # Convert arch to lowercase
  arch="$(echo "$arch" | tr '[:upper:]' '[:lower:]')"
  verbose "Host architecture: $arch"

  # Set aliases for architectures
  amd64=("amd64" "x86_64" "x86-64" "x64")
  amd32=("386" "i386" "i686" "x86")
  arm=("arm" "armv7" "armv6" "armv8" "armv8l" "armv7l" "armv6l" "armv8l" "armv7l" "armv6l")

  currentArchAliases=()
  # Set the right aliases for current host system
  if [ $arch == "x86_64" ]; then
    currentArchAliases=("${amd64[@]}")
  elif [ $arch == "i386" ] || [ $arch == "i686" ]; then
    currentArchAliases=("${amd32[@]}")
  # Else if starts with "arm"
  elif [[ $arch =~ ^arm ]]; then
    currentArchAliases=("${arm[@]}")
  else
    error "Unsupported architecture: $arch"
    exit 1
  fi
  verbose "Current architecture aliases: ${currentArchAliases[*]}"

  # Get operating system of host
  os="$(uname -s)"
  # Convert os to lowercase
  os="$(echo "$os" | tr '[:upper:]' '[:lower:]')"
  verbose "Host operating system: $os"

  # Set aliases for operating systems
  linux=("linux")
  darwin=("darwin" "macos" "osx")

  currentOsAliases=()
  # If current os is linux, add linux aliases to the curentOsAliases array
  if [ "${os}" == "linux" ]; then
    currentOsAliases+=(${linux[@]})
  elif [ "${os}" == "darwin" ]; then
    currentOsAliases+=(${darwin[@]})
  fi
  verbose "Current operating system aliases: ${currentOsAliases[*]}"

  # Create map of assets and a score
  for asset in $assets; do
    score=0

    # Get file name from asset path
    fileName="$(echo "$asset" | awk -F'/' '{ print $NF; }')"
    # Set filename to lowercase
    fileName="$(echo "$fileName" | tr '[:upper:]' '[:lower:]')"

    # Set score to one, if the file name contains the current os
    for osAlias in "${currentOsAliases[@]}"; do
      if [[ "${fileName}" == *"$osAlias"* ]]; then
        score=1
        break
      fi
    done

    # Skip assets that do not match the operating system of the host
    if [ $score != 1 ]; then
      verbose "Skipping asset $fileName because it does not match the current operating system"
      continue
    fi

    verbose "$fileName matches current operating system"

    # Add one to the score for every alias that matches the current architecture
    for archAlias in "${currentArchAliases[@]}"; do
      if [[ "${fileName}" == *"$archAlias"* ]]; then
        verbose "Adding one to score for asset $fileName because it matches architecture $archAlias"
        score=$((score + 1))
      fi
    done

    # Initialize asset with score
    map_put assets "$fileName" "$score"
  done

  # Get map entry with highest score
  verbose "Finding asset with highest score"
  maxScore=0
  maxKey=""
  for key in $(map_keys assets); do
    score="$(map_get assets "$key")"
    if [ $score -gt $maxScore ]; then
      maxScore=$score
      maxKey=$key
    fi
  done

  assetName="$maxKey"
  # Get asset URL from release assets
  assetURL="$(echo "$assets" | grep -i "$assetName")"
fi

info "Found asset with highest match score: $assetName"

info "Downloading asset..."
# Download asset
downloadAssetArgs=$curlOpts
downloadAssetArgs+=(-L "$assetURL" -o "$tmpDir/$assetName")
cmd="curl ${downloadAssetArgs[@]}"
verbose "$cmd"
$cmd
if [ $? -ne 0 ]; then
  error "Error while running the curl command."
  exit 1
fi

# Unpack asset if it is a tar, tar.gz or tar.bz2 file
info "Unpacking $assetName asset"
if [[ "$assetName" == *".tar" ]]; then
  tar -xf "$tmpDir/$assetName" -C "$tmpDir"
elif [[ "$assetName" == *".tar.gz" ]]; then
  tar -xzf "$tmpDir/$assetName" -C "$tmpDir"
elif [[ "$assetName" == *".tar.bz2" ]]; then
  tar -xjf "$tmpDir/$assetName" -C "$tmpDir"
else
  error "Unsupported archive format: $assetName"
  exit 1
fi

# Removing packed asset
verbose "Removing packed asset"
rm "$tmpDir/$assetName"

# Copy files to install location
info "Installing '$repo'"
verbose "Copying files to install location"
cp -r "$tmpDir"/* "$installLocation"

# Find binary in install location to symlink to it later
verbose "Finding binary in install location"
binary=""
cd "$installLocation/$repo"*
for file in $(ls); do
  # Check if the main file is a binary file
  verbose "Checking if $file is a binary file"
  if file "$file" | grep -q "executable"; then
    verbose "$file is a binary file"
    # Check if the name of the file contains the name of the repo
    if echo "$file" | grep -q "$repo"; then
      verbose "$file contains the name of the repo"
      binary="$file"
      break
    fi
  fi
done

# Check if binary was found
if [ -z "$binary" ]; then
  error "Could not find valid binary in install location"
  exit 1
fi

# Get name of binary
binaryName="$(basename "$binary")"
verbose "Binary name: $binaryName"

# Remove previous symlink if it exists
verbose "Removing previous symlink"
rm "$binaryLocation/$binaryName" > /dev/null 2>&1 || true
# Create symlink to binary
verbose "Creating symlink '$binaryLocation/$binaryName' -> '$binary'"
ln -s "$installLocation/$repo"*/"$binary" "$binaryLocation/$binaryName"
ln -s "$installLocation/$repo"*/personal_utils.py "$binaryLocation/personal_utils.py"
# Check if ln created a broken symlink
if [ ! -e "$binaryLocation/$binaryName" ]; then
  error "Could not create symlink"
  exit 1
fi

# Make symlink executable
verbose "Making symlink executable"
chmod +x "$binaryLocation/$binaryName"

# Add binaryLocation to PATH, if it is not already in PATH
if ! echo "$PATH" | grep -q "$binaryLocation"; then
  verbose "Adding $binaryLocation to PATH"
  # Append binaryLocation to .profile, if it is not already in .profile
  if ! grep -q -s "export PATH=$binaryLocation:\$PATH" "$HOME/.profile"; then
    verbose "Appending $binaryLocation to $HOME/.profile"
    echo "export PATH=$binaryLocation:\$PATH" >> "$HOME/.profile"
  fi
fi

# Install required dependencies from requirements.txt
if [ -f "$installLocation/$repo"*/requirements.txt ]; then
  info "Installing dependencies from requirements.txt"
  cmd="pip3 install -r $installLocation/$repo*/requirements.txt"
  verbose "$cmd"
  $cmd > /dev/null 2>&1
  if [ $? -ne 0 ]; then
    error "Error while running the pip3 command."
    exit 1
  fi
fi

info "Running clean up..."
verbose "Removing temporary directory"
rm -rf "$tmpDir"

echo
success "You can now run '$binaryName' in your terminal."
info "You might have to restart your terminal session for the changes to take effect."

# Notify user the user of succes installation with notify-send if it is installed
if command -v notify-send >/dev/null 2>&1; then
  notify-send "Successfully installed $repo"
fi


##################################################################################
# MIT License                                                                    #
#                                                                                #
# Copyright (c) 2022 Marvin Wendt (Instl | https://instl.sh)                     #
#                                                                                #
# Permission is hereby granted, free of charge, to any person obtaining a copy   #
# of this software and associated documentation files (the "Software"), to deal  #
# in the Software without restriction, including without limitation the rights   #
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      #
# copies of the Software, and to permit persons to whom the Software is          #
# furnished to do so, subject to the following conditions:                       #
#                                                                                #
# The above copyright notice and this permission notice shall be included in all #
# copies or substantial portions of the Software.                                #
#                                                                                #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     #
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       #
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    #
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         #
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  #
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  #
# SOFTWARE.                                                                      #
##################################################################################

# --------------------------------- Metadata ----------------------------------- #

# Script generated for https://github.com/yisuschrist/urls_organizer
# Script generated at 2023-04-30 13:43:02.75054673 +0000 UTC m=+3258407.419020364
# Script generated for version "latest"
